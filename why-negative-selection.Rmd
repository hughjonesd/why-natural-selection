---
title: "Negative Selection in the 20th Century"
author: "David Hugh-Jones, Abdel Abdellaoui"
date: "April 2020"
output: 
  bookdown::pdf_document2:
    toc: false
    latex_engine: xelatex
---

```md
# TODO

* Why so many missings for age_fulltime_edu?
  - ah, need f.6138 for those who went to college
  - but note that YearsEdu.ISCED has many fewer missings
  - ask Abdel how it was calculated
  - use this for survey weighting?
  
* Look at geography, esp. in siblings regressions.


* Work more on weighting the data?
  - weight by age at first live birth
  - education using ISCED?
  - geography?
  - ask for existing work by others?

* control for age in n_partners regressions


## Data to gather
* f.2139 - age first had sex (includes "never had sex" which may explain
  some of the many NAs for f.2141, num sex partners)

```

```{r setup, include = FALSE}

library(drake)
library(magrittr)
library(dplyr)
library(forcats)
library(ggplot2)
library(tidyr)
library(santoku) # keep this after tidyr as it masks chop
library(purrr)
library(glue)
library(broom)
library(huxtable)


drake::loadd(rgs)
drake::loadd(score_names)

options(digits = 2)
knitr::opts_chunk$set(
        echo = FALSE, 
        warning = FALSE, 
        cache = FALSE, 
        error = TRUE
      )

huxtable::set_default_properties(latex_float = "h!")

theme_set(theme_minimal())
my_hline <- geom_hline(yintercept = 0, colour = "grey20", linetype = "dotted")
my_vline <- geom_vline(xintercept = 0, colour = "grey20", linetype = "dotted")
pval_palette <- c("FALSE" = "grey50", "TRUE" = "orange2")


pval_scale <- function (...) scale_color_manual(values = pval_palette, ...)


pval_geom_point <- function (size = 1.5, stroke = 0.7, ...) {
  geom_point(shape = 21, size = size, stroke = stroke, ...)
}


my_fill_scale <- function (n, aesthetics = "fill", ...) {
  if (n == 2) {
    scale_color_brewer(type = "qual", palette = 3, aesthetics = aesthetics, ...)
  } else {
    scale_color_brewer(aesthetics = aesthetics, ...)
  }
}


my_labs <- function (x = "Effect size", y = "", ...) labs(x = x, y = y, ...)


# for use when reordering factors. Order by the nth score in a group
order_abs <- function (n = 1) {
  function (x) x[n] 
}

pretty_names <- function (names) {
  names <- gsub("_", " ", names)
  names %<>% 
        strsplit(" ") %>% 
        map_chr(~paste0(
          toupper(substring(.x, 1, 1)), 
          substring(.x, 2),
          collapse = " "
        ))

  acronyms <- c("WHR", "BMI", "DPW", "CPD", "SI", "AI", "WC")
  for (acronym in acronyms) {
    regex <- paste0("\\b", acronym, "\\b")
    names <- gsub(regex, toupper(acronym), names, ignore.case = TRUE)
  }
  
  return(names)
}

```


# Data

Data is taken from UK Biobank. Polygenic scores were  normalized to mean 0,
variance 1. 

# Results



```{r calc-means-over-time}

drake::loadd(famhist)
pgs_over_time <- famhist %>% 
      group_by(
        YOB = santoku::chop(YOB, 
          brk_left(seq(1940, 1970, 5), close_end = FALSE), 
          seq(40, 65, 5),
          extend = FALSE
        ) 
      ) %>% 
      filter(! is.na(YOB)) %>% 
      summarize(across(all_of(score_names), mean, na.rm = TRUE)) %>% 
      pivot_longer(
        -YOB, 
        names_to = "score_name",
        values_to = "score"
      ) 
 
```


```{r calc-means-over-time-children, eval = FALSE}
pgs_over_time_children <- famhist %>% 
      mutate(
        YOB_kids = (year_flb + year_llb)/2,
        YOB      = santoku::chop(
                     YOB_kids, 
                     brk_left(seq(1960, 1995, 5), close_end = FALSE), 
                     seq(60, 90, 5),
                     extend = FALSE
                   )
      ) %>% 
      filter(! is.na(YOB)) %>% 
      group_by(YOB) %>% 
      summarize(across(all_of(score_names), 
        ~weighted.mean(.x, n_children, na.rm = TRUE)
      )) %>% 
      pivot_longer(-YOB, names_to = "score_name", values_to = "score")

pgs_over_time <- bind_rows(
        Respondents = pgs_over_time,
        Children    = pgs_over_time_children,
        .id         = "Generation"
      )

```


```{r plot-means-over-time, fig.cap = "Mean polygenic scores by birth year in UK Biobank. Lines are means for 5-year intervals"}
pgs_over_time %>% 
      mutate(score_name = pretty_names(score_name)) %>% 
      ggplot(aes(YOB, score, group = score_name)) + 
      geom_line() +
      facet_wrap(~score_name) +
      theme(
        strip.text  = element_text(size = 7), 
        axis.text.x = element_text(size = 7)
      ) +
      labs(y = "PGS", x = "Birth year (5 year intervals)")
```

We run regressions on two dependent variables:

* *siblings*, the number of full siblings in the respondent's sib (including
  himself or herself).
* The number of *children* ever born to/fathered by the respondent.

We run regressions both with and without controls for the 100 top principal
components of the genetic data.


```{r regs-data}

drake::loadd(res_all)

res_all_wide <- res_all %>% 
  select(reg.type, dep.var, term, estimate) %>% 
  pivot_wider(names_from = c(reg.type, dep.var), values_from = estimate) %>% 
  mutate(
    consistent = sign(`raw_N siblings`) == sign(`controlled_N siblings`) &
      sign(`raw_N siblings`) == sign(`raw_N children`) &
      sign(`raw_N siblings`) == sign(`controlled_N children`)
  )

n_pgs  <- as.double(nrow(res_all_wide))
prop_consistent <- mean(res_all_wide$consistent)
controlled_smaller_sibs <- abs(res_all_wide[["controlled_N siblings"]]) < 
  abs(res_all_wide[["raw_N siblings"]])
controlled_smaller_children <- abs(res_all_wide[["controlled_N children"]]) < 
  abs(res_all_wide[["raw_N children"]])
median_prop_sibs <- median(abs(res_all_wide[["controlled_N siblings"]]) /
    abs(res_all_wide[["raw_N siblings"]]))
median_prop_children <- median(abs(res_all_wide[["controlled_N children"]]) /
    abs(res_all_wide[["raw_N children"]]))

prop_gens_raw <- res_all_wide[["raw_N children"]]/res_all_wide[["raw_N siblings"]]
prop_gens_controlled <- res_all_wide[["controlled_N children"]]/res_all_wide[["controlled_N siblings"]]
median_prop_gens_raw <- median(prop_gens_raw[prop_gens_raw > 0])
median_prop_gens_controlled <- median(prop_gens_controlled[prop_gens_controlled > 0])
```



Figure \@ref(fig:plot-basic-regs) shows effect sizes of a one-standard
deviation shift in each polygenic score. 

Estimates are broadly consistent across generations. For 
`r sum(res_all_wide$consistent)` out of `r n_pgs` polygenic scores, all 4 
estimates have the same sign. 

However, effect sizes are much smaller for *children* than *siblings*
regressions. Among consistently-signed estimates, the median effect size for
children as a proportion of the effect size for  siblings is 
`r median_prop_gens_raw`, or `r median_prop_gens_controlled` with controls.

In siblings regressions, effect sizes are smaller when controlling for
principal components -- sometimes much smaller, as in the case of height. 
`r sum(controlled_smaller_sibs)` out of `r n_pgs` "controlled" effect sizes have 
a smaller absolute value than the corresponding "raw" effect size. The median
proportion between raw and controlled effect sizes is `r median_prop_sibs`.
Among the children regressions, this no longer holds. Effect sizes are barely
affected by controlling for principal components.


```{r plot-basic-regs, fig.cap = "Effects of polygenic scores on number of siblings/children.", fig.height = 7}

drake::loadd(res_all)

n_regs <- as.double(nrow(res_all))
res_all %>% 
      mutate(
        term    = pretty_names(term),
        term    = fct_reorder(term, estimate, order_abs(1)),
        dep.var = fct_inorder(dep.var) 
      ) %>% 
      ggplot(aes(y = term, x = estimate, fill = reg.type, 
        colour = p.value < 0.05/{{n_regs}})) +
      my_vline + 
      pval_geom_point() +
      labs(x = "Effect size", y = "") +
      facet_wrap(vars(dep.var), ncol = 2) +
      pval_scale() +
      my_fill_scale(n = 2, guide = guide_legend(title = "")) +
      theme(
        legend.position = "bottom", 
        legend.margin   = margin(2, 2, 2, 2)
      )

```

```{r}
drake::loadd(res_pcs)
n_regs <- as.double(nrow(res_pcs))
prop_sig <- res_pcs %>% 
      group_by(dep.var) %>% 
      summarize(sig = sum(p.value <= 0.05/nrow(res_pcs))) %>% 
      pull(sig, name = dep.var)
```


To get a further insight into this we regress *siblings* and *children* on
individual principal components. As Figure \@ref(fig:plot-pc-regs)
shows, effects are larger and more significant in siblings regressions. 
`r prop_sig[["N siblings"]]` principal components significantly predicted number of
siblings, while only `r prop_sig[["N children"]]` significantly predicted number
of children.



```{r plot-pc-regs, fig.cap = "Effect of principal components of genetic data on number of siblings/children. Absolute effect sizes are plotted. Each dot represents one bivariate regression. Points are jittered on the Y axis.", fig.height = 2}

res_pcs %>% 
      mutate(
        estimate = abs(estimate),
        dep.var  = fct_relevel(dep.var, "N children")
      ) %>% 
      ggplot(aes(estimate, dep.var, colour = p.value < 0.05/{{n_regs}})) + 
        geom_jitter(height = 0.15, width = 0, alpha = 0.9) + 
        scale_x_log10(labels = scales::label_number(accuracy = 0.0001)) +
        labs(x = "Effect size (log scale)", y = "") + 
        pval_scale(aesthetics = "colour")
        

```


# Selection over time


```{r period-regs-data}

drake::loadd(res_period)
res_period %<>% 
      tidyr::extract(term, c("period", "score_name"),
        regex="year_split(.*):(.*)")
n_tests <- nrow(res_period)/2


summary_period <- res_period %>% 
      select(-std.error, -statistic) %>% 
      pivot_wider(
        names_from  = period, 
        values_from = c(estimate, conf.low, conf.high, p.value)
      ) %>% 
      group_by(score_name, children) %>% 
      mutate(
        significant = diff.p.value < 0.05/n_tests,
        sign_early  = sign(estimate_early),
        sign_late   = sign(estimate_late),
        size_inc    = abs(estimate_early) < abs(estimate_late),
        change_sign = sign_early != sign_late,
        Change      = case_when(
                        ! significant ~ "Insignificant",
                        change_sign   ~ "Change sign",
                        size_inc      ~ "Size increasing",
                        ! size_inc    ~ "Size decreasing"
                      )
      ) %>% 
      select(score_name, children, Change, significant, change_sign, 
        sign_early, sign_late) %>% 
      mutate(children = ifelse(children, "Respondents", "Parents")) %>% 
      pivot_wider(names_from = children, 
        values_from = c(Change, significant, change_sign, sign_early, 
        sign_late)) %>% 
      mutate(overall = case_when(
              ! change_sign_Parents & ! change_sign_Respondents & 
                sign_late_Parents == sign_early_Parents ~ 
                "Consistent",
              TRUE ~ "Changes direction"
            ))



```



Negative selection seems to decrease over time. Figure \@ref(fig:plot-by-period) shows
effect sizes for *number of siblings* and *number of children*, median-split by
parents' year of birth and own year of birth respectively.  Parents' year of
birth is imputed, which is likely to produce some bias.



```{r plot-by-period, fig.cap = "Effect sizes of PGS on number of children/siblings by own/parents' year of birth. PGS with the largest mean effect sizes are shown.", fig.height = 7, fig.width = 6}

max_abs <- function (x) max(abs(x))
res_period %>% 
      mutate(
        dep.var       = ifelse(children, "Children", "Siblings"),
        period        = (period == "late") + children,
        score_name    = pretty_names(score_name),
        score_name    = fct_reorder(score_name, estimate, max_abs, 
                          .desc = TRUE),
        p             = diff.p.value
      ) %>% 
      arrange(score_name) %>% 
      slice(1:48) %>% 
ggplot(aes(period, estimate, colour = dep.var, group = dep.var)) + 
      geom_hline(yintercept = 0, colour = "grey30") + 
      geom_point(size = 1.5) +
      geom_line(aes(linetype = p < 0.05/{{n_tests}})) +
      facet_wrap(vars(score_name), nrow = 4) + 
      pval_scale() +
      my_fill_scale(n = 2, aesthetics = "colour") +
      scale_linetype_manual(values = c("FALSE" = "dashed", "TRUE" = "solid"))
      
      
```


By definition, the sibling regressions exclude members of the parents'
generation who had no children. This is likely to bias results towards zero, since
much of the effect in children regressions is due to respondents with high scores
being more likely to have no children. So, we cannot directly compare 
effect sizes for the two sets of regressions. Within the sibling regressions,
the most common pattern is that negative effects shrink in absolute size 
(Table \@ref(tab:siblings-by-period)).


```{r siblings-by-period}

period_table <- function (tbl, caption) {
  tbl %>% 
      as_hux() %>%
      set_bold(1, everywhere) %>% 
      set_bottom_border(1, everywhere) %>% 
      
      add_footnote(glue("Significance is measured at p < 0.05/{n_tests}"), 
        border = 0.4) %>% 
      set_contents(1, everywhere, 
        c("Change", "Number of scores")) %>% 
      set_right_border(final(1), 1, 0) %>% 
      set_top_padding(1) %>% 
      set_bottom_padding(1) %>%
      set_left_padding(everywhere, 1, 0) %>% 
      set_right_padding(everywhere, 2, 0) %>% 
      set_caption(caption) %>% 
      set_caption_width(1)
}

summary_period %>% 
      group_by(Change_Parents) %>% 
      count() %>% 
      period_table("Change in effect sizes between early and late born parents, 'sibling' regressions")
      
```

In children regressions, no clear pattern is visible 
(Table \@ref(tab:children-by-period)).


```{r children-by-period}
summary_period %>% 
      group_by(Change_Respondents) %>% 
      count() %>% 
      period_table("Change in effect sizes between early and late born respondents, 'children' regressions")
```



```{r res-weighted}

drake::loadd(res_weighted)
res_weighted_all <- res_weighted %>% 
      left_join(
        res_all %>% 
              filter(dep.var == "N children", reg.type == "raw") %>% 
              select(term, estimate),
        by = "term",
        suffix = c("_weighted", "_unweighted")
      ) %>% 
      mutate(
        prop_wtd_unwtd = estimate_weighted/estimate_unweighted
      )

mean_prop_wtd_unwtd <- res_weighted_all %>% 
      filter(sign(estimate_weighted) == sign(estimate_unweighted)) %>% 
      summarize(mean = mean(prop_wtd_unwtd)) %>% 
      pull(mean)

```


# Accounting for ascertainment bias

Effect sizes tend to be smaller for children regressions. This
could be caused by ascertainment bias in the UK Biobank sample -- e.g.,
if respondents themselves are a more selected sample than the respondents' 
parents. To check this, we weighted UK Biobank participants by age of leaving
full time education. Our sample weights are based on the 2006 General Household
Survey, calculating proportions within age and sex cells among White British
respondents. We then rerun the basic *children* regressions.

Figure \@ref(fig:plot-weighted) shows the results, with unweighted estimates
plotted for comparison. Weighting increases effect sizes on average by 
`r 100 * (mean_prop_wtd_unwtd - 1)` per cent. These weights are only basic 
attempts to correct for ascertainment bias. Effect sizes might be increased 
further by more precise weighting.


```{r plot-weighted, fig.cap = "Effects of polygenic scores on number of children, regressions weighted by education levels within age categories"}


n_regs <- as.double(nrow(res_weighted_all))

res_weighted_all %>% 
      mutate(
        term    = pretty_names(term),
        term    = fct_reorder(term, estimate_weighted, order_abs(1))
      ) %>% 
      pivot_longer(cols = c(estimate_weighted, estimate_unweighted), 
        names_to = "Regression", values_to = "estimate") %>% 
      mutate(
        Regression = sub("estimate_", "", Regression)
      ) %>% 
      ggplot(aes(y = term, x = estimate, fill = Regression,
        colour = p.value < 0.05/{{n_regs}})) +
      my_vline + 
      pval_geom_point() +
      labs(x = "Effect size", y = "") +
      my_fill_scale(n = 2) +
      pval_scale(aesthetics = "colour")

```



# Causality


```{r pgs-corrs}
cor_tbl <- cor(famhist[score_names], use = "pair") %>% 
      as_tibble() %>% 
      mutate(score_name = score_names, .before = 1) %>% 
      pivot_longer(cols = -score_name, values_to = "Correlation") %>% 
      filter(score_name < name) %>% 
      arrange(desc(Correlation)) %>% 
      slice(1:10) %>% 
      mutate(across(c(score_name, name), pretty_names)) 

as_hux(cor_tbl, add_colnames = TRUE) %>% 
      set_contents(1, 1:2, c("PGS", "PGS")) %>% 
      theme_basic(header_col = FALSE) %>% 
      set_bottom_border(1, everywhere, 0.4) %>% 
      set_bottom_border(final(1), everywhere, 0.4) %>% 
      set_caption("Top 10 correlations between polygenic scores")

```

Different polygenic scores are correlated. Table \@ref(tab:pgs-corrs) shows the top
correlations in the sample. Because of this, bivariate correlations between
PGS and number of children might be driven by other genetic scores. To explore which polygenic scores are driving negative selection, we run a single
omnibus regression of *number of children* on all the PGS. We exclude EA2, 
waist-hip ratio, waist-circumference, and "Hip combined" since they are 
highly correlated with other scores, which could make our estimates unstable. Figure \@ref(fig:plot-together) shows the results. Interestingly, several PGS remain independently significant, although
effect sizes are reduced.

```{r plot-together, fig.cap = "Partial correlations with number of children"}

loadd(res_together)
n_regs <- as.double(nrow(res_together))
res_together %>% 
      mutate(
        term = pretty_names(term),
        term = fct_reorder(term, estimate, order_abs(2)),
        dep.var = dplyr::recode(dep.var, 
          "n_children" = "N Children", "n_sibs" = "N Siblings"),
        dep.var = fct_relevel(dep.var, "N Siblings")
      ) %>% 
      ggplot(aes(y = term, x = estimate, color = p.value < 0.05/{{n_regs}}, 
        fill  = PCs)) + 
        pval_geom_point(alpha = 0.8) +
        my_vline +
        facet_wrap(vars(dep.var)) +
        pval_scale() +
        my_fill_scale(n = 2, direction = -1) +
        my_labs() +
        theme(legend.position = "bottom")
```


# Subgroups

We next examine how different subgroups contribute to natural selection. 


## Males and females

```{r}

drake::loadd(res_sex)

female_lower <- res_sex %>% 
      pivot_wider(id_cols = c(term), names_from = sex, 
        values_from = c(estimate, conf.low, conf.high)) %>% 
      mutate(female_lower = estimate_Female < estimate_Male) %>% 
      pull(female_lower)
```


Figure \@ref(fig:plot-sexes) shows effect sizes of PGS on number of children
separately for males and females. For `r sum(female_lower)` out of
`r length(female_lower)` PGS, selection is more negative for women
than for men. Differences are particularly large for educational attainment and height PGS.


```{r plot-sexes, fig.cap = "Effect sizes on number of children by sex"}

n_regs <- as.double(nrow(res_sex))
res_sex %>% 
      mutate(
        term = pretty_names(term),
        term = fct_reorder(term, estimate, order_abs(1))
      ) %>% 
      ggplot(aes(y = term, x = estimate, fill = sex, 
            colour = p.value < 0.05/{{n_regs}})) +
        my_vline +
        pval_geom_point() +
        pval_scale() +
        my_fill_scale(n = 2, direction = -1) +
        my_labs()

```


## Age at first live birth


```{r corr-age-flb}

drake::loadd(res_age_flb)
drake::loadd(res_sex)

res_sex_comparison <- res_sex %>% 
      filter(sex == "Female") %>% 
      mutate(score_name = term) %>% 
      select(score_name, term, estimate:conf.high)

res_age_flb %<>% filter(term != "age_flb") 

res_combined <- bind_rows(
        raw      = res_sex_comparison, 
        with_age = res_age_flb %>% select(score_name, term, estimate:conf.high), 
        .id      = "reg.type"
      ) %>% 
      arrange(score_name)

raw_flb_comparison <- res_combined %>% 
      pivot_wider(
        id_cols     = score_name, 
        names_from  = reg.type, 
        values_from = estimate
      )

cor_raw_flb <- cor(raw_flb_comparison$raw, raw_flb_comparison$with_age)
opp_signed <- sum(
        sign(raw_flb_comparison$raw) != sign(raw_flb_comparison$with_age)
      )

```



Figure \@ref(fig:plot-age-flb) shows the results of *children* regressions for 
women only,
controlling for age at first live birth. Effect sizes are greatly reduced.
In `r opp_signed` out of `r length(score_names)` cases, they are of the 
opposite sign. The correlation between effect sizes
controlling for age at first live birth, and raw effect sizes, is `r cor_raw_flb`.


```{r plot-age-flb, fig.cap = "Effect sizes on number of children, controlling for age at first live birth (women only). Effect sizes for women without controls are shown for comparison"}

n_regs <- as.double(nrow(res_age_flb))

res_combined %>% 
      mutate(
        score_name = fct_reorder(score_name, estimate, order_abs(2)),
        Regression = ifelse(reg.type == "raw", "Bivariate", "Controlled for age FLB")
      ) %>% 
      ggplot(aes(y = score_name, x = estimate, fill = Regression, 
        color = p.value < 0.05/{{n_regs}})) + 
        geom_vline(xintercept = 0, linetype = "dashed", color = "grey20") +
        pval_geom_point() +
        pval_scale() +
        scale_fill_brewer(type = "qual", palette = 3) +
        my_labs()
```



```{r calc-age-birth-parents}

drake::loadd(res_age_birth_parents)
drake::loadd(res_all)

res_sibs_raw <- filter(res_all, dep.var == "N siblings", reg.type == "raw")
compare_abp_raw <- res_age_birth_parents %>% 
      filter(! term %in% c("fath_age_birth", "moth_age_birth")) %>% 
      left_join(res_sibs_raw, by = "term")

cor_raw_fath <- with(
  compare_abp_raw %>% filter(control == "fath_age_birth"), 
  cor(estimate.x, estimate.y))
cor_raw_moth <- with(
  compare_abp_raw %>% filter(control == "moth_age_birth"), 
  cor(estimate.x, estimate.y))
```

We can run similar regressions for the parents' generation, using the subsets of respondents who reported their mother's or father's age
and who had no elder siblings. We run *sibling* regressions on these subsets,
controlling for either parent's age at their birth.
Figure \@ref(fig:plot-age-birth-parents) shows
the results. Effect sizes are very similar, whether controlling for
father's or mother's age at respondent's birth or mother's age at respondent's birth. Unlike for the respondents' generation, effect sizes are positively correlated with
the effect sizes from bivariate regressions (father's age at birth: 
$\rho$ `r cor_raw_fath`; mother's age at birth: $\rho$ `r cor_raw_moth`).


```{r plot-age-birth-parents, fig.cap = "Effect sizes on number of siblings controlling for parents' age at birth, eldest siblings"}


n_regs <- as.double(nrow(res_age_birth_parents)/2)

res_age_birth_parents %>% 
    filter(! term %in% c("fath_age_birth", "moth_age_birth")) %>% 
    mutate(
      term    = pretty_names(term),
      term    = fct_reorder(term, estimate, order_abs(2)),
      Control = ifelse(control == "fath_age_birth", 
                  "Father's age at birth", 
                  "Mother's age at birth"
                )
    ) %>% 
    ggplot(aes(y = term, x = estimate, fill = Control, 
      colour = p.value < 0.05/{{n_regs}})) + 
      pval_geom_point(alpha = 0.8) +  
      my_vline +
      my_fill_scale(2) +
      pval_scale() +
      my_labs()

```


```{r calc-age-flb-dv}

drake::loadd(res_age_flb_dv)
drake::loadd(res_age_birth_parents_dv)

compare_flb_dv <- left_join(
        res_age_flb_dv           %>% select(term, estimate),
        res_age_birth_parents_dv %>% select(term, estimate, dep.var),
        by = "term"
      )

cor_flb_fath <- with(compare_flb_dv %>% filter(dep.var == "fath_age_birth"),
        cor(estimate.x, estimate.y)
      )
cor_flb_moth <- with(compare_flb_dv %>% filter(dep.var == "moth_age_birth"),
        cor(estimate.x, estimate.y)
      )
```

These results suggest that polygenic scores may directly correlate with
age at first live birth. Figure \@ref(fig:plot-age-flb-dv) plots
estimated effect sizes from bivariate regressions for respondents, and
Figure \@ref(fig:plot-age-birth-parents-dv) does the same for their parents. 
Effect sizes are reasonably large. They are also very highly correlated across 
generations. Effect sizes of PGS on father's age at own birth, and on own age
at first live birth, have a correlation of `r cor_flb_fath`; for mother's age
and own age it is `r cor_flb_moth`


```{r plot-age-flb-dv, fig.cap = "Effects of polygenic scores on age at first live birth"}

n_regs <- as.double(nrow(res_age_flb_dv))

res_age_flb_dv %>% 
      mutate(
        term = pretty_names(term),
        term = fct_reorder(term, estimate, order_abs(1))
      ) %>% 
      ggplot(aes(estimate, term, colour = p.value < 0.05 / {{n_regs}})) + 
      my_vline +
      pval_geom_point(fill = "steelblue4") +
      pval_scale() + 
      my_labs()

```





```{r plot-age-birth-parents-dv, fig.cap = "Effects of polygenic scores on parents' age at own birth, eldest siblings"}

n_regs <- as.double(nrow(res_age_birth_parents_dv))

res_age_birth_parents_dv %>% 
      mutate(
        term = pretty_names(term),
        term = fct_reorder(term, estimate, order_abs(1)),
        "Dependent variable" = dplyr::recode(dep.var, 
          "fath_age_birth" = "Father's age", 
          "moth_age_birth" = "Mother's age"
        )
      ) %>% 
      ggplot(aes(estimate, term, fill = `Dependent variable`, 
        colour = p.value < 0.05 / {{n_regs}})) + 
        my_vline +
        pval_geom_point() +
        pval_scale() +
        my_fill_scale(n = 2, direction = -1) +
        my_labs()

```

## Number of sexual partners

Figure \@ref(fig:plot-n-partners) splits males and females up by lifetime number
of sexual partners. Remarkably, across both sexes, negative selection is
strongly reversed for respondents who had 3 or fewer sexual partners in their
lifetime.


```{r plot-n-partners, fig.cap = "Effect sizes on number of children by number of sexual partners", fig.height = 7, fig.width = 6}

drake::loadd(res_partners)
res_partners %<>%       
      filter(term != "(Intercept)", term != "lo_partnersTRUE") %>% 
      mutate(`N partners` = ifelse(grepl(":", term), "<= 3", "> 3")) 

n_regs <- as.double(nrow(res_partners))
res_partners %>% 
      mutate(
        score_name = pretty_names(score_name),
        score_name = fct_reorder(score_name, estimate, order_abs(1))
      ) %>% 
      ggplot(aes(y = score_name, x = estimate, fill = `N partners`, 
        colour = p.value < 0.05/{{n_regs}})) + 
        my_vline +
        pval_geom_point() +
        facet_wrap(vars(sex)) +
        my_fill_scale(n = 2) +
        pval_scale() +
        theme(legend.position = "bottom") +
        my_labs(x = "", y = "")

      

```


## Education and income


Figure \@ref(fig:plot-educ-levels) splits respondents up by education levels.
Both negative and positive selection are typically larger and more significant
for those who left school before 16. Table \@ref(tab:educ-levels) summarizes
the results.


```{r educ-levels}
loadd(res_edu)
res_edu %>% 
      mutate(
        age_fte_cat = fct_relevel(age_fte_cat, "< 16", "16-18", "> 18")
      ) %>% 
      group_by(age_fte_cat) %>% 
      summarize(
        prop_sig = 100 * mean(p.value < 0.05/nrow(res_edu)), 
        .groups  = "drop"
      ) %>% 
      as_huxtable(add_colnames = TRUE) %>% 
      set_contents(1, everywhere, 
        c("Age left FTE", "% PGS significant")) %>%
      set_caption("Negative selection by education level") %>% 
      set_bold(1, everywhere, TRUE) %>% 
      set_bottom_border(1, everywhere, 0.4) %>% 
      set_left_padding(everywhere, 1, 0) %>% 
      set_right_padding(everywhere, final(1), 0) %>% 
      set_top_padding(14)

```




```{r plot-educ-levels, fig.cap = "Effect sizes on number of children by age left full-time education"}

drake::loadd(res_edu)
n_regs <- as.double(nrow(res_edu))
res_edu %>% 
      mutate(
        term = pretty_names(term), 
        term = fct_reorder(term, estimate, order_abs(1)),
        "Age left FTE" = fct_relevel(age_fte_cat, "< 16", "16-18", "> 18")
      ) %>% 
      ggplot(aes(y = term, x = estimate, colour = p.value < 0.05/{{n_regs}}, 
        fill = `Age left FTE`)) +
        my_vline +
        pval_geom_point() + 
        pval_scale() +
        my_fill_scale(n = 3, direction = -1) +
        my_labs()
        
```


Figure \@ref(fig:plot-income) splits respondents by household income category.
A very similar pattern holds, with selection effects being larger for those
in the poorest income category.


```{r plot-income, fig.cap = "Effect sizes on number of children by household income"}

drake::loadd(res_income)

n_regs <- as.double(nrow(res_income))
res_income %>% 
      mutate(
        term = pretty_names(term), 
        term = fct_reorder(term, estimate, order_abs(1)),
        Income = factor(income_cat, 
          labels = c("< £18K", "£18-30K", "£31-51K", "£52-100K", "> £100K")
        )
      ) %>% 
      ggplot(aes(y = term, x = estimate, fill = Income, 
        colour = p.value < 0.05/{{n_regs}})) +
        my_vline +
        pval_geom_point(alpha = 0.8) + 
        my_fill_scale(n = 5, direction = -1) +
        pval_scale() +
        my_labs()
```


```{r income-edu-controlled}
drake::loadd(res_income_controlled, res_edu_controlled)
n_regs_ic <- nrow(res_income_controlled)
n_sig_ic <- sum(res_income_controlled$p.value < 0.05/n_regs_ic)

n_regs_educ <- nrow(res_edu_controlled)
n_sig_educ <- sum(res_edu_controlled$p.value < 0.05/n_regs_educ)
```


These results could be driven by age, if older respondents are poorer and less
educated, and also more subject to selection on polygenic scores. However, if we
rerun the regressions, interacting the polygenic score with income category and
also with a quadratic in age, the interaction with income remains significant at
0.05/`r n_regs_ic` for `r n_sig_ic` out of `r n_regs_ic` regressions. Similarly
if we interact the PGS with age of leaving full time education and a quadratic
in age, the interaction with age leaving FTE remains significant at 
0.05/`r n_regs_educ` for `r n_sig_educ` out of `r n_regs_educ` regressions.


# Number of children


Figure \@ref(fig:plot-n-children-bar) shows the full distribution of number 
of children born for different ventiles of the EA3 polygenic score. The 
strongest relationship seems to be for having 0 children versus 1 or more.


```{r plot-n-children-bar, fig.cap = "Number of children by ventiles of EA3 PGS"}
famhist %>% 
      select(n_children, EA3_excl_23andMe_UK, sex) %>% 
      mutate(
        "EA3 Ventile" = chop_equally(EA3_excl_23andMe_UK, 20, labels = 1:20),
        "N Children"  = santoku::chop(n_children, brk_left(0:4, FALSE), 
                          labels = c(0:3, "4+")),
        Sex           = factor(sex, levels = 0:1, labels = c("Female", "Male"))
        ) %>% 
      filter(! is.na(`EA3 Ventile`), ! is.na(`N Children`)) %>% 
      ggplot(aes(`EA3 Ventile`, fill = `N Children`, group = `N Children`)) + 
        geom_bar(position = position_fill(reverse = TRUE), alpha = 0.7) + 
        facet_wrap(vars(Sex)) +
        scale_fill_viridis_d(option = "A") +
        scale_y_continuous(n.breaks = 10, labels = scales::percent) +
        theme(legend.position = "bottom")


```



```{r plot-sd-years, eval = FALSE}
# inequality over time. Nothing to see, almost everything is flat.
grid <- expand_grid(score_name = score_names, YOB = 1940:1965)  
grid$sd <- pmap_dbl(grid, ~sd(famhist[famhist$YOB==.y, ][[.x]], na.rm = TRUE))
ggplot(grid, aes(YOB, sd)) + 
      geom_line() + 
      facet_wrap(~score_name, scales = "free_y", ncol = 4)
```


```{r rgs-by-effect-size, eval = FALSE, fig.cap = "Genetic correlations with EA3 by effect size on n siblings."}
rgs <- left_join(rgs, res %>% filter(reg.type == "residualized"), by = c("p2" = "term"))

rgs %>% 
      filter(p2 != "EA3_excl_23andMe_UK", p2 != "EA2_noUKB") %>% 
      ggplot(aes(rg, estimate)) + 
        geom_smooth(method = lm) +
        geom_point(colour = "red2") + 
        geom_label(aes(label = p2, hjust = "left", vjust = "middle"), 
          size = 3, nudge_x = 0.02, alpha = 0.5, 
          label.padding = unit(0.1, "lines")) +
        labs(x = "rG", y = "Effect size", 
          title = "rG with EA3 vs. effect size on # siblings")
```

```{r correlate-effect-sizes, eval = FALSE}
combined_results <- res %>% 
      mutate(PCs = ifelse(reg.type=="raw", "no", "yes")) %>% 
      dplyr::select(-reg.type) %>% 
      {bind_rows(bivariate = ., multivariate = all_res, .id = "reg.type")} %>% 
      arrange(term, reg.type, PCs) %>% 
      dplyr::select(term, reg.type, PCs, estimate) %>% 
      pivot_wider(names_from = c(reg.type, PCs), values_from = estimate)

cor(combined_results[-1], use = "complete")

```

