---
title: "Negative Selection in the 20th Century"
author: "David Hugh-Jones"
date: "April 2020"
output: 
  bookdown::pdf_document2:
    toc: false
---

```{r setup, include = FALSE}

draft <- FALSE # set to FALSE to reset the cache

pgs_dir  <- "~/UKBB data 2019/polygenic_scores/"
ph_file  <- "~/UKBB data 2019/UKB.EA_pheno.coordinates.QC.david.csv"
pcs_file <- "~/UKBB data 2019/ukb30545.40PCs.csv"
famhist_file <- "~/Dropbox/assortative mating/biobank-analysis/david.family_history.traits.out.csv"
famhist2_file <- "~/UKBB data 2019/david.family_history.traits.20042020.out.csv"
famhist3_file <- "~/UKBB data 2019/david.family_history.traits.05052020.out.csv"
rgs_file <- "EA3_rgs.10052019.rgs.csv"
mf_pairs_file <- "~/UKBB data 2019/spouse_pair_info/UKB_out.mf_pairs_rebadged.csv"

library(readr)
library(multcomp) # keep before dplyr, it masks select
library(magrittr)
library(dplyr)
library(forcats)
library(ggplot2)
library(tidyr)
library(santoku) # keep this after tidyr as it masks chop
library(purrr)
library(glue)
library(broom)
library(huxtable)


options(digits = 2)
knitr::opts_chunk$set(
        echo = FALSE, 
        warning = FALSE, 
        cache = draft, 
        error = draft
      )
theme_set(theme_minimal())

order_abs <- function (x) x[1] # for use when reordering factors
pretty_names <- function (name) {
  name <- gsub("_", " ", name)
  name <- strsplit(name, " ")
  map_chr(name, 
        ~paste0(
          toupper(substring(.x, 1, 1)), 
          substring(.x, 2),
          collapse = " "
        ))
}

ph_spec <- spec_csv(ph_file)
ph <- read_csv(ph_file, col_types = cols(
        geno_measurement_plate = col_skip(),
        geno_measurement_well = col_skip(),
        .default = col_double()
      ))
pcs <- read_csv(pcs_file)
rgs <- read_csv(rgs_file)
famhist <- read_csv(famhist_file, col_types = strrep("d", 40))
famhist2 <- read_csv(famhist2_file, col_types = strrep("d", 17))
famhist3 <- read_csv(famhist3_file)
mf_pairs <- read_csv(mf_pairs_file, col_types = "dddccccc")

names(famhist) <- paste0("f.", names(famhist))
names(famhist) <- gsub("\\-", ".", names(famhist))
names(famhist2) <- paste0("f.", names(famhist2))
names(famhist2) <- gsub("\\-", ".", names(famhist2))
names(famhist3) <- paste0("f.", names(famhist3))
names(famhist3) <- gsub("\\-", ".", names(famhist3))

famhist %<>% left_join(pcs, by = c("f.eid" = "eid"))
famhist %<>% left_join(ph, by = c("f.eid" = "eid"))
famhist %<>% left_join(famhist2, by = "f.eid")
famhist %<>% left_join(famhist3, by = "f.eid")

# only "genetic" whites
famhist %<>% filter(! is.na(genetic_ethnic_grouping))

for (pgs_file in list.files(pgs_dir, pattern = "csv$", full.names = TRUE)) {
  score_name <- sub(".*UKB\\.AMC\\.(.*?)\\..*", "\\1", pgs_file, perl = TRUE)
  
  pgs <- read_delim(pgs_file, delim = " ", col_types = "dd")
  
  pgs %<>% filter(FID > 0) 
  names(pgs)[2] <- score_name # instead of "SCORE"
  pgs[[score_name]] <- c(scale(pgs[[score_name]]))
  
  famhist %<>% left_join(pgs, by = c("f.eid" = "FID"))
  
  resid_fml <- paste(score_name, "~", paste0("PC", 1:40, collapse = " + "))
  resid_score <- resid(lm(as.formula(resid_fml), famhist, na.action = na.exclude))
  famhist[[paste0(score_name, "_resid")]] <- c(scale(resid_score))
}

score_names <- sub(".*UKB\\.AMC\\.(.*?)\\..*", "\\1", 
      list.files(pgs_dir, pattern = "csv$"), perl = TRUE)

# we get very few extra cases from adding f.2946.1.0 etc, and it makes calculating
# father's year of birth more complex
# roughly speaking, these are ages in 2007-10
# TODO: get f.53 from Abdel for these EIDs
famhist$fath_age <- famhist$f.2946.0.0
famhist$fath_age[famhist$fath_age < 0] <- NA
famhist$moth_age <- famhist$f.1845.0.0
famhist$moth_age[famhist$moth_age < 0] <- NA

# full brothers and sisters
famhist$nbro <- pmax(famhist$f.1873.0.0, famhist$f.1873.1.0, 
      famhist$f.1873.2.0, na.rm = TRUE)
famhist$nbro[famhist$nbro < 0] <- NA
famhist$nsis <- pmax(famhist$f.1883.0.0, famhist$f.1883.1.0, 
      famhist$f.1883.2.0, na.rm = TRUE)
famhist$nsis[famhist$nsis < 0] <- NA
famhist$n_sibs <- famhist$nbro + famhist$nsis

famhist$n_partners <- pmax(famhist$f.2149.0.0, famhist$f.2149.1.0, 
     famhist$f.2149.2.0, na.rm = TRUE)
famhist$n_partners[famhist$n_partners < 0] <- NA

famhist$n_children <- pmax(famhist$f.2405.0.0, famhist$f.2405.1.0,
        famhist$f.2405.2.0, famhist$f.2734.0.0, famhist$f.2734.1.0, 
        famhist$f.2734.2.0, 
        na.rm = TRUE
      )
famhist$n_children[famhist$n_children < 0] <- NA

child_vars <- quos(f.2754.0.0, f.2754.1.0, f.2754.2.0)
famhist %<>% mutate_at(vars(!!!child_vars), ~ ifelse(.x < 0, NA, .x))
famhist$age_flb <- rowMeans(famhist %>% select(!!!child_vars), na.rm = TRUE)
famhist$year_flb <- famhist$YOB + famhist$age_flb

reverse_code <- c("agreeableness", "age_at_menarche", "age_at_menopauze",
  "cognitive_ability", "conscientiousness", "EA2_noUKB",
  "EA3_excl_23andMe_UK", "extraversion", "height_combined",
  "openness")
famhist[reverse_code] <- famhist[reverse_code] * -1

rgs$p2 <- rgs$p2 %>% recode(
        EA3_excl_23andMe_and_allUK = "EA3_excl_23andMe_UK",
        cognitve_ability.noUKB     = "cognitive_ability",
        autism_2017.ipsych.pgc     = "autism_2017",
      ) %>% {sub("\\.GPC\\.23andme$", "", .)}

rm(famhist2, famhist3, pgs, pcs, ph)
```

```{r make-pairs, eval = FALSE}
famhist_tmp <- famhist %>% dplyr::select(! (starts_with("f.") | 
      starts_with("PC") | starts_with("home") |
      starts_with("assessment") | starts_with("birth_")), f.eid)
mf_pairs %<>% 
      left_join(famhist_tmp, by = c("ID.m" = "f.eid")) %>% 
      left_join(famhist_tmp, by = c("ID.f" = "f.eid"), suffix = c(".m", ".f"))
rm(famhist_tmp)

```

# Data

Data is taken from UK Biobank. Polygenic scores were  normalized to mean 0,
variance 1. Scores for educational attainment, cognitive ability, height,
extraversion, agreeableness, conscientiousness, age at menarche, and age at
menopause were reverse coded. High scores are therefore "negative" in the loose
sense that their target phenotypes would be considered undesirable by many
people.

# Results


We run regressions on two dependent variables:

* log(total siblings + 1), where *total siblings* includes the
  respondent. 
* log(children + 1) where *children* is the number of 
  children ever born to/fathered by the respondent.

We run regressions both with and without controls for the 40 top principal components
of the genetic data.


```{r run-regs}
# for each score, calculate the correlation with number of siblings
# 
run_regs <- function (dep_var, score_name) {
  fml <- as.formula(glue("{dep_var} ~ {score_name}"))
  reg_bv <- tidy(lm(fml, famhist), conf.int = TRUE) 
  
  pcs <- paste0("PC", 1:40, collapse = " + ")
  fml_resid <- as.formula(glue("{dep_var} ~ {score_name} + {pcs}"))
  reg_resid <- tidy(lm(fml_resid, famhist), conf.int = TRUE)
  
  regs <- bind_rows(raw = reg_bv, controlled = reg_resid, .id = "reg.type")
  regs %<>% filter(term != "(Intercept)", ! grepl("^PC", term))
  
  return(regs)
}

# we use n_sibs + 2 to be directly comparable to log(n_children + 1)
res_sibs <- map_dfr(score_names, run_regs, dep_var = "log(n_sibs + 2)")
res_chn <- map_dfr(score_names, run_regs, dep_var = "log(n_children + 1)")

res_all <- bind_rows("N siblings" = res_sibs, "N children" = res_chn, 
      .id = "dep.var")

res_all_wide <- res_all %>% 
      select(reg.type, dep.var, term, estimate) %>% 
      pivot_wider(names_from = c(reg.type, dep.var), values_from = estimate) %>% 
      mutate(
        consistent = sign(`raw_N siblings`) == sign(`controlled_N siblings`) &
                     sign(`raw_N siblings`) == sign(`raw_N children`) &
                     sign(`raw_N siblings`) == sign(`controlled_N children`)
      )

n_regs <- as.double(nrow(res_all))
n_pgs  <- as.double(nrow(res_all_wide))
prop_consistent <- mean(res_all_wide$consistent)
controlled_smaller_sibs <- abs(res_all_wide[["controlled_N siblings"]]) < 
               abs(res_all_wide[["raw_N siblings"]])
controlled_smaller_children <- abs(res_all_wide[["controlled_N children"]]) < 
               abs(res_all_wide[["raw_N children"]])
median_prop_sibs <- median(abs(res_all_wide[["controlled_N siblings"]]) /
               abs(res_all_wide[["raw_N siblings"]]))
median_prop_children <- median(abs(res_all_wide[["controlled_N children"]]) /
               abs(res_all_wide[["raw_N children"]]))
```



Figure \@ref(fig:basic-regs) shows effect sizes of a one-standard
deviation shift in each polygenic score. 

Estimates are broadly consistent
across generations. For `r sum(res_all_wide$consistent)` out of 
`r n_pgs` polygenic scores, all 4 estimates have the same sign.

Within siblings regressions, effect sizes are smaller when controlling for 
principal components -- sometimes much smaller, as in the case of height. 
`r sum(controlled_smaller_sibs)` out of `r n_pgs`
"controlled" effect sizes have a smaller absolute value than the corresponding 
"raw" effect size. The median proportion between raw and controlled effect sizes
is just `r median_prop_sibs`.

Among the children regressions, this no longer holds. Only 
`r sum(controlled_smaller_children)` residualized effect sizes out of `r n_pgs`
are smaller. The median proportion between effect sizes is `r median_prop_children`.


```{r basic-regs, fig.cap = "Effects of polygenic scores on number of siblings/children", fig.height = 7}

shape21 <- guide_legend(override.aes = list(shape = 21))
res_all %>% 
      mutate(term = fct_reorder(term, estimate, order_abs)) %>% 
      ggplot(aes(x = term, y = estimate, fill = reg.type, shape = dep.var,
        colour = p.value < 0.05/{{n_regs}})) +
      geom_hline(yintercept = 0, colour = "grey40", linetype = "dashed") + 
      geom_point(stroke = 0.75, size = 2) + 
      labs(y = "Effect size", x = "") +
      coord_flip() +
      scale_shape_manual(values = c("N siblings" = 21, "N children" = 23)) +
      scale_fill_brewer(guide = shape21, type = "qual", palette = 3) +
      scale_colour_manual(
        values = c("FALSE" = "grey80", "TRUE" = "orange2"), 
        guide = shape21
      ) 

```

# Selection over time


```{r run-regs-period}
run_regs_period <- function(children, score_name, period) {
  dep_var  <- if (children) "log(n_children)" else "log(n_sibs + 1)"
  year_var <- if (children) "year_flb" else "YOB"
  famhist$in_period <- ! is.na(famhist[[year_var]]) & 
                       famhist[[year_var]] %in% period:(period+9)
  
  dep_var_col <- if (children) "n_children" else "n_sibs"
  fh_subset <- famhist[
          famhist$in_period & 
          ! is.na(famhist[[dep_var_col]]) & 
          ! is.na(famhist[[score_name]])
        , ]
  # for strict comparability to the siblings regression, we include only
  # those with 1 child or more
  if (children) fh_subset <- fh_subset[fh_subset$n_children > 0, ] 
  if (nrow(fh_subset) < 1000) return(NULL)

  fml <- as.formula(glue("{dep_var} ~ {score_name}"))
  mod <- lm(fml, fh_subset)
  res <- tidy(mod, conf.int = TRUE)
  res <- filter(res, term == score_name)
  res$period <- period
  res$children <- children
  res
}

pars <- expand_grid(
        children = c(TRUE, FALSE),
        score_name = score_names, 
        period = seq(1940, 2000, 10)
      )
res_yr <- pmap_dfr(pars, run_regs_period)

```


```{r plot-by-period, fig.cap = "Effect sizes of PGS on number of children/siblings by ten year periods", fig.height = 7, fig.width = 6}
res_yr %>% 
      mutate(
        dep.var = ifelse(children, "Children", "Siblings")
      ) %>% 
ggplot(aes(period, estimate, group = dep.var)) + 
      geom_hline(yintercept = 0, colour = "grey50", size = 0.5) +
      geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.3, fill = "lightblue") +
      geom_line(aes(linetype = dep.var), colour = "navy") + 
      facet_wrap(
        vars(term), 
        scales = "free_y", 
        ncol = 4, 
        strip.position = "bottom"
      ) +
      theme(
        panel.grid.minor.y = element_blank(), 
        legend.title = element_blank()
      )
```

Selection over time appears to be decreasing. Figure \@ref(fig:plot-by-period) shows
effect sizes estimated within 10 year periods. Sibling regressions use the
respondent's own birth year. Children regressions use the year of the
respondent's first live birth. Since this is not available for men, only female
respondents are included. By definition, the sibling regressions exclude members
of the parents' generation who had no children. To make the effect size
estimates as comparable as possible, children regressions include only
respondents with at least one child ever born; the dependent variable is
*log(number of children)* or *log(total number of siblings)*.

Despite this, effect sizes tend to be smaller for children regressions. This
could be caused by ascertainment bias in the UK Biobank sample -- e.g.,
if respondents themselves are a more selected sample than the respondents' 
parents.

## Subgroups

We next examine the correlates of natural selection by running regressions on
*log(number of children + 1)* within various subgroups of the sample.

```{r run-regs-subset}

run_regs_subset <- function(score_name, subset) {
  fml <- as.formula(glue("log(n_children + 1) ~ {score_name}"))
  mod <- lm(fml, famhist, subset = eval(subset))
  res <- tidy(mod, conf.int = TRUE)
  res <- filter(res, term == {{score_name}})
  res$subset <- list(subset)
  res
}

subsets <- rlang::exprs(sex == 0, sex == 1)
par <- expand_grid(score_name = score_names, subset = subsets)
res_subsets <- pmap_dfr(par, run_regs_subset)
```

```{r fn-plot-subsets}
plot_subsets <- function(ss_name, ss_expr, ...) {
  ss_name <- rlang::enquo(ss_name)
  subset_expr <- rlang::enexprs(...)
  res_subsets %>% 
        filter(subset %in% !!subset_expr) %>% 
        mutate(
          subset = as.character(subset), 
          !!ss_name := {{ss_expr}},
          term = fct_reorder(term, estimate, order_abs)
        ) %>% 
        ungroup() %>% 
        ggplot(aes(term, estimate, group = !!ss_name, colour = !!ss_name)) +
          geom_hline(yintercept = 0, colour = "grey20") +
          geom_pointrange(aes(ymin = conf.low, ymax = conf.high), alpha = 0.7) +
          coord_flip() +
          scale_colour_brewer(palette = 2, type = "qual")
}
```


Figure \@ref(fig:plot-sexes) shows effect sizes of PGS on number of children
separately for males and females. Education and height PGS are strongly
negatively selected among women.

```{r plot-sexes, fig.cap = "Effect sizes on number of children by sex"}
plot_subsets(
        Sex, 
        recode(subset, "sex == 0" = "Female", "sex == 1" = "Male"),
        sex == 0, sex == 1
      )
```




```{r plot-sd-years, eval = FALSE}
# inequality over time. Nothing to see, almost everything is flat.
grid <- expand_grid(score_name = score_names, YOB = 1940:1965)  
grid$sd <- pmap_dbl(grid, ~sd(famhist[famhist$YOB==.y, ][[.x]], na.rm = TRUE))
ggplot(grid, aes(YOB, sd)) + 
      geom_line() + 
      facet_wrap(~score_name, scales = "free_y", ncol = 4)
```


```{r rgs-by-effect-size, eval = FALSE, fig.cap = "Genetic correlations with EA3 by effect size on n siblings."}
rgs <- left_join(rgs, res %>% filter(reg.type == "residualized"), by = c("p2" = "term"))

rgs %>% 
      filter(p2 != "EA3_excl_23andMe_UK", p2 != "EA2_noUKB") %>% 
      ggplot(aes(rg, estimate)) + 
        geom_smooth(method = lm) +
        geom_point(colour = "red2") + 
        geom_label(aes(label = p2, hjust = "left", vjust = "middle"), 
          size = 3, nudge_x = 0.02, alpha = 0.5, 
          label.padding = unit(0.1, "lines")) +
        labs(x = "rG", y = "Effect size", 
          title = "rG with EA3 vs. effect size on # siblings")
```

```{r correlate-effect-sizes, eval = FALSE}
combined_results <- res %>% 
      mutate(PCs = ifelse(reg.type=="raw", "no", "yes")) %>% 
      dplyr::select(-reg.type) %>% 
      {bind_rows(bivariate = ., multivariate = all_res, .id = "reg.type")} %>% 
      arrange(term, reg.type, PCs) %>% 
      dplyr::select(term, reg.type, PCs, estimate) %>% 
      pivot_wider(names_from = c(reg.type, PCs), values_from = estimate)

cor(combined_results[-1], use = "complete")

```

