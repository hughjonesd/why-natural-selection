---
title: "Negative Selection in the 20th Century"
author: "David Hugh-Jones"
date: "April 2020"
output: 
  bookdown::pdf_document2:
    toc: false
---

```{r setup, include = FALSE}

draft <- FALSE # set to FALSE to reset the cache

pgs_dir  <- "~/UKBB data 2019/polygenic_scores/"
ph_file  <- "~/UKBB data 2019/UKB.EA_pheno.coordinates.QC.david.csv"
pcs_file <- "~/UKBB data 2019/ukb30545.40PCs.csv"
famhist_file <- "~/Dropbox/assortative mating/biobank-analysis/david.family_history.traits.out.csv"
famhist2_file <- "~/UKBB data 2019/david.family_history.traits.20042020.out.csv"
famhist3_file <- "~/UKBB data 2019/david.family_history.traits.05052020.out.csv"
rgs_file <- "EA3_rgs.10052019.rgs.csv"
mf_pairs_file <- "~/UKBB data 2019/spouse_pair_info/UKB_out.mf_pairs_rebadged.csv"

library(readr)
library(multcomp) # keep before dplyr, it masks select
library(magrittr)
library(dplyr)
library(forcats)
library(ggplot2)
library(tidyr)
library(santoku) # keep this after tidyr as it masks chop
library(purrr)
library(glue)
library(broom)
library(huxtable)


knitr::opts_chunk$set(
        echo = FALSE, 
        warning = FALSE, 
        cache = draft, 
        error = draft
      )
theme_set(theme_minimal())

order_abs <- function (x) x[1] # for use when reordering factors

ph_spec <- spec_csv(ph_file)
ph <- read_csv(ph_file, col_types = cols(
        geno_measurement_plate = col_skip(),
        geno_measurement_well = col_skip(),
        .default = col_double()
      ))
pcs <- read_csv(pcs_file)
rgs <- read_csv(rgs_file)
famhist <- read_csv(famhist_file, col_types = strrep("d", 40))
famhist2 <- read_csv(famhist2_file, col_types = strrep("d", 17))
famhist3 <- read_csv(famhist3_file)
mf_pairs <- read_csv(mf_pairs_file, col_types = "dddccccc")

names(famhist) <- paste0("f.", names(famhist))
names(famhist) <- gsub("\\-", ".", names(famhist))
names(famhist2) <- paste0("f.", names(famhist2))
names(famhist2) <- gsub("\\-", ".", names(famhist2))
names(famhist3) <- paste0("f.", names(famhist3))
names(famhist3) <- gsub("\\-", ".", names(famhist3))

famhist %<>% left_join(pcs, by = c("f.eid" = "eid"))
famhist %<>% left_join(ph, by = c("f.eid" = "eid"))
famhist %<>% left_join(famhist2, by = "f.eid")
famhist %<>% left_join(famhist3, by = "f.eid")

# only "genetic" whites
famhist %<>% filter(! is.na(genetic_ethnic_grouping))

for (pgs_file in list.files(pgs_dir, pattern = "csv$", full.names = TRUE)) {
  score_name <- sub(".*UKB\\.AMC\\.(.*?)\\..*", "\\1", pgs_file, perl = TRUE)
  
  pgs <- read_delim(pgs_file, delim = " ", col_types = "dd")
  
  pgs %<>% filter(FID > 0) 
  names(pgs)[2] <- score_name # instead of "SCORE"
  pgs[[score_name]] <- c(scale(pgs[[score_name]]))
  
  famhist %<>% left_join(pgs, by = c("f.eid" = "FID"))
  
  resid_fml <- paste(score_name, "~", paste0("PC", 1:40, collapse = " + "))
  resid_score <- resid(lm(as.formula(resid_fml), famhist, na.action = na.exclude))
  famhist[[paste0(score_name, "_resid")]] <- c(scale(resid_score))
}

score_names <- sub(".*UKB\\.AMC\\.(.*?)\\..*", "\\1", 
      list.files(pgs_dir, pattern = "csv$"), perl = TRUE)

# we get very few extra cases from adding f.2946.1.0 etc, and it makes calculating
# father's year of birth more complex
# roughly speaking, these are ages in 2007-10
# TODO: get f.53 from Abdel for these EIDs
famhist$fath_age <- famhist$f.2946.0.0
famhist$fath_age[famhist$fath_age < 0] <- NA
famhist$moth_age <- famhist$f.1845.0.0
famhist$moth_age[famhist$moth_age < 0] <- NA

# full brothers and sisters
famhist$nbro <- pmax(famhist$f.1873.0.0, famhist$f.1873.1.0, 
      famhist$f.1873.2.0, na.rm = TRUE)
famhist$nbro[famhist$nbro < 0] <- NA
famhist$nsis <- pmax(famhist$f.1883.0.0, famhist$f.1883.1.0, 
      famhist$f.1883.2.0, na.rm = TRUE)
famhist$nsis[famhist$nsis < 0] <- NA
famhist$n_sibs <- famhist$nbro + famhist$nsis

famhist$n_partners <- pmax(famhist$f.2149.0.0, famhist$f.2149.1.0, 
     famhist$f.2149.2.0, na.rm = TRUE)
famhist$n_partners[famhist$n_partners < 0] <- NA

famhist$n_children <- pmax(famhist$f.2405.0.0, famhist$f.2405.1.0,
        famhist$f.2405.2.0, famhist$f.2734.0.0, famhist$f.2734.1.0, 
        famhist$f.2734.2.0, 
        na.rm = TRUE
      )
famhist$n_children[famhist$n_children < 0] <- NA

child_vars <- quos(f.2754.0.0, f.2754.1.0, f.2754.2.0)
famhist %<>% mutate_at(vars(!!!child_vars), ~ ifelse(.x < 0, NA, .x))
famhist$age_flb <- rowMeans(famhist %>% select(!!!child_vars), na.rm = TRUE)
famhist$year_flb <- famhist$YOB + famhist$age_flb

rgs$p2 <- rgs$p2 %>% recode(
        EA3_excl_23andMe_and_allUK = "EA3_excl_23andMe_UK",
        cognitve_ability.noUKB     = "cognitive_ability",
        autism_2017.ipsych.pgc     = "autism_2017",
      ) %>% {sub("\\.GPC\\.23andme$", "", .)}

rm(famhist2, famhist3, pgs, pcs, ph)
```

```{r make-pairs, eval = FALSE}
famhist_tmp <- famhist %>% dplyr::select(! (starts_with("f.") | 
      starts_with("PC") | starts_with("home") |
      starts_with("assessment") | starts_with("birth_")), f.eid)
mf_pairs %<>% 
      left_join(famhist_tmp, by = c("ID.m" = "f.eid")) %>% 
      left_join(famhist_tmp, by = c("ID.f" = "f.eid"), suffix = c(".m", ".f"))
rm(famhist_tmp)

```

# Results


We run regressions on two dependent variables:

* log(total siblings + 1), where *total siblings* includes the
  respondent. 
* log(children + 1) where *children* is the number of 
  children ever born to/fathered by the respondent.

We run regressions both with and without controls for the 40 top principal components
of the genetic data.


```{r run-regressions}
# for each score, calculate the correlation with number of siblings
# 
run_regs <- function (dep_var, score_name) {
  fml <- as.formula(glue("{dep_var} ~ {score_name}"))
  reg_bv <- tidy(lm(fml, famhist), conf.int = TRUE) 
  
  pcs <- paste0("PC", 1:40, collapse = " + ")
  fml_resid <- as.formula(glue("{dep_var} ~ {score_name} + {pcs}"))
  reg_resid <- tidy(lm(fml_resid, famhist), conf.int = TRUE)
  
  regs <- bind_rows(raw = reg_bv, controlled = reg_resid, .id = "reg.type")
  regs %<>% filter(term != "(Intercept)", ! grepl("^PC", term))
  
  return(regs)
}

# we use n_sibs + 2 to be directly comparable to log(n_children + 1)
res_sibs <- map_dfr(score_names, run_regs, dep_var = "log(n_sibs + 2)")
res_chn <- map_dfr(score_names, run_regs, dep_var = "log(n_children + 1)")

res_all <- bind_rows("N siblings" = res_sibs, "N children" = res_chn, 
      .id = "dep.var")

res_all_wide <- res_all %>% 
      select(reg.type, dep.var, term, estimate) %>% 
      pivot_wider(names_from = c(reg.type, dep.var), values_from = estimate) %>% 
      mutate(
        consistent = sign(`raw_N siblings`) == sign(`controlled_N siblings`) &
                     sign(`raw_N siblings`) == sign(`raw_N children`) &
                     sign(`raw_N siblings`) == sign(`controlled_N children`)
      )

n_regs <- as.double(nrow(res_all))
n_pgs  <- as.double(nrow(res_all_wide))
prop_consistent <- mean(res_all_wide$consistent)
controlled_smaller_sibs <- abs(res_all_wide[["controlled_N siblings"]]) < 
               abs(res_all_wide[["raw_N siblings"]])
controlled_smaller_children <- abs(res_all_wide[["controlled_N children"]]) < 
               abs(res_all_wide[["raw_N children"]])
median_prop_sibs <- median(abs(res_all_wide[["controlled_N siblings"]]) /
               abs(res_all_wide[["raw_N siblings"]]))
median_prop_children <- median(abs(res_all_wide[["controlled_N children"]]) /
               abs(res_all_wide[["raw_N children"]]))
```



Figure \@ref(fig:basic-regs) shows effect sizes of a one-standard
deviation shift in each polygenic score. 

Estimates are broadly consistent
across generations. For `r sum(res_all_wide$consistent)` out of 
`r n_pgs` polygenic scores, all 4 estimates have the same sign.

Within siblings regressions, effect sizes are smaller when controlling for 
principal components -- sometimes much smaller, as in the case of height. 
`r sum(controlled_smaller_sibs)` out of `r n_pgs`
"controlled" effect sizes have a smaller absolute value than the corresponding 
"raw" effect size. The median proportion between raw and controlled effect sizes
is just `r median_prop_sibs`.

Among the children regressions, this no longer holds. Only 
`r sum(controlled_smaller_children)` residualized effect sizes out of `r n_pgs`
are smaller. The median proportion between effect sizes is `r median_prop_children`.


```{r basic-regs, fig.cap = "Effects of polygenic scores on number of siblings/children", fig.height = 7}

shape21 <- guide_legend(override.aes = list(shape = 21))
res_all %>% 
      mutate(term = fct_reorder(term, estimate, order_abs)) %>% 
      ggplot(aes(x = term, y = estimate, fill = reg.type, shape = dep.var,
        colour = p.value < 0.05/{{n_regs}})) +
      geom_hline(yintercept = 0, colour = "grey40", linetype = "dashed") + 
      geom_point(stroke = 0.75, size = 2) + 
      labs(y = "Effect size", x = "") +
      coord_flip() +
      scale_shape_manual(values = c("N siblings" = 21, "N children" = 23)) +
      scale_fill_brewer(guide = shape21, type = "qual", palette = 3) +
      scale_colour_manual(
        values = c("FALSE" = "grey80", "TRUE" = "orange2"), 
        guide = shape21
      ) 

```

# Selection over time


```{r}
run_regs_time <- function(children, score_name, period) {
  dep_var  <- if (children) "log(n_children + 1)" else "log(n_sibs + 2)"
  year_var <- if (children) "year_flb" else "YOB"
  famhist$in_period <- ! is.na(famhist[[year_var]]) & famhist[[year_var]] %in% period:(period+4)
  
  dep_var_col <- if (children) "n_children" else "n_sibs"
  fh_subset <- famhist[
          famhist$in_period & 
          ! is.na(famhist[[dep_var_col]]) & 
          ! is.na(famhist[[score_name]])
        , ]
  # for strict comparability to the siblings regression, we include only
  # those with 1 child or more
  if (children) fh_subset <- fh_subset[fh_subset$n_children > 0, ] 
  if (nrow(fh_subset) < 1000) return(NULL)

  fml <- as.formula(glue("{dep_var} ~ {score_name}"))
  mod <- lm(fml, fh_subset)
  res <- tidy(mod, conf.int = TRUE)
  res <- filter(res, term == score_name)
  res$period <- period
  res$children <- children
  res
}

pars <- expand_grid(
        children = c(TRUE, FALSE),
        score_name = score_names, 
        period = seq(1940, 2000, 5)
      )
res_yr <- pmap_dfr(pars, run_regs_time)

```


```{r over-time}

ggplot(res_yr, aes(period, estimate, colour = children)) + 
      geom_linerange(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
      geom_line() + 
      facet_wrap(vars(term))
```

Selection over time appears to be decreasing, if we focus on raw PGS. Figure
\@ref(fig:effect-sizes-by-period) shows effect sizes for  survey respondents
born in the 1930s and 1940s, versus respondents born in the 1950s to 1970s.


```{r effect-sizes-by-period, fig.cap = "Effect sizes of PGS on n children by period. Significance tests compare early to late effect sizes", fig.width = 6, fig.height = 7}

famhist$period <- chop(famhist$YOB, c(1930, 1950, 1974), 
      labels = c("30s_40s", "50s_70s"))

run_time_regs <- function(score_name) {
  
  fml <- as.formula(glue("log(n_sibs+1) ~ {score_name}:period"))
  mod <- lm(fml, famhist)
  res <- tidy(mod)
  res <- filter(res, ! term %in% c("(Intercept)"))
  res$term <- gsub(".*:period", "", res$term)
  
  glhts <- list(
    glht(mod, glue("{score_name}:period30s_40s - {score_name}:period50s_70s = 0"))
  )
  glhts <- glhts %>% map(summary) %>% map(tidy) %>% map_dbl("p.value")
  res$glht.p.value <- c(NA, glhts)
  
  res
}

names(score_names) <- score_names
time_regs <- map_dfr(score_names, run_time_regs, .id = "reg")

time_regs %<>% 
      rename(period = term) %>% 
      mutate(reg = fct_reorder(reg, estimate, first))

time_regs_wide <- time_regs %>% 
      select(reg, period, estimate, glht.p.value) %>% 
      pivot_wider(reg, names_from = period, 
        values_from = c(estimate, glht.p.value)) %>% 
      mutate(Significant = glht.p.value_50s_70s < 0.05/(nrow(time_regs) * 3/4))

time_regs %>% 
      group_by(reg) %>% 
      mutate(
        Significant = na.omit(glht.p.value) < 0.05/(nrow(time_regs) * 3/4)
      ) %>% 
      ggplot(aes(x = reg)) +
        geom_hline(yintercept = 0, colour = "darkgrey") +
        geom_linerange(aes(
          ymin = estimate_30s_40s, 
          ymax = estimate_50s_70s, colour = Significant), 
          data = time_regs_wide) + 
        geom_point(aes(y = estimate, fill = period, colour = Significant), 
          shape = 21, size = 2) + 
        scale_colour_manual(values = c("grey", "orange3")) +
        scale_fill_brewer(type = "qual", palette = 3) +
        coord_flip()
```

# Causality

To be selected against, an allele does not need to cause fewer children, only to
be correlated with fewer children. Nevertheless, it is interesting to ask
whether individual PGS caused sample members' parents to have fewer children. As
a first cut, we regress log(number of siblings _+ 1) on all PGS together. We run
two regressions: one controlling for genetic principal components, and one
without these controls. Figure \@ref(fig:multivariate-reg-plots) shows the results.

```{r multivariate-regs}

# EA3 and EA2 have a 0.9 raw correlation. These are the only pair of PGS with
# a raw correlation of more than 0.8
reg_score_names <- setdiff(score_names, "EA2_noUKB")

without_pcs <- paste0("log(n_sibs+1) ~ ", paste(reg_score_names, collapse = " + "))
fml <- as.formula(without_pcs)
fml_with_pcs <- as.formula(paste(without_pcs, "+", paste0("PC", 1:40, 
      collapse = " + ")))

all_mod <- lm(fml, famhist)
all_res <- tidy(all_mod, conf.int = TRUE) 

all_mod_pcs <- lm(fml_with_pcs, famhist)
all_res_pcs <- tidy(all_mod_pcs, conf.int = TRUE)

all_res <- bind_rows(no = all_res, yes = all_res_pcs, .id = "PCs")
all_res <- filter(all_res, term != "(Intercept)", ! grepl("^PC", term))

```

```{r multivariate-reg-plots, fig.cap = "Multivariate regressions. Significance tests compare effect sizes to zero."}

all_res$term <- fct_reorder(all_res$term, all_res$estimate, order_abs)

n_regs <- as.double(nrow(all_res)) # avoids an ugly "L"
ggplot(all_res, aes(term)) + 
      geom_point(aes(y = estimate, fill = PCs, 
        colour = p.value <= 0.05/{{n_regs}}), shape = 21) + 
      scale_colour_manual(values = c("grey", "black")) +
      geom_hline(yintercept = 0, colour = "darkgrey") +
      labs(x = "PGS", y = "Effect size") +
      coord_flip() 
```


```{r rgs-by-effect-size, eval = FALSE, fig.cap = "Genetic correlations with EA3 by effect size on n siblings."}
rgs <- left_join(rgs, res %>% filter(reg.type == "residualized"), by = c("p2" = "term"))

rgs %>% 
      filter(p2 != "EA3_excl_23andMe_UK", p2 != "EA2_noUKB") %>% 
      ggplot(aes(rg, estimate)) + 
        geom_smooth(method = lm) +
        geom_point(colour = "red2") + 
        geom_label(aes(label = p2, hjust = "left", vjust = "middle"), 
          size = 3, nudge_x = 0.02, alpha = 0.5, 
          label.padding = unit(0.1, "lines")) +
        labs(x = "rG", y = "Effect size", 
          title = "rG with EA3 vs. effect size on # siblings")
```

```{r correlate-effect-sizes, eval = FALSE}
combined_results <- res %>% 
      mutate(PCs = ifelse(reg.type=="raw", "no", "yes")) %>% 
      dplyr::select(-reg.type) %>% 
      {bind_rows(bivariate = ., multivariate = all_res, .id = "reg.type")} %>% 
      arrange(term, reg.type, PCs) %>% 
      dplyr::select(term, reg.type, PCs, estimate) %>% 
      pivot_wider(names_from = c(reg.type, PCs), values_from = estimate)

cor(combined_results[-1], use = "complete")

```

